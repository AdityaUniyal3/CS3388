#version 400
layout(quads, equal_spacing) in;

uniform mat4 MVP;
uniform mat4 M;  // Model matrix only
uniform mat4 V;  // View matrix only
uniform mat4 P;  // Projection matrix only

// Inputs must match TCS outputs exactly
in vec3 normal_te[];
in vec3 position_te[];
in vec3 eye_te[];
in vec3 light_te[];
in vec2 uv_te[];

out vec3 normal_tes;
out vec3 position_tes;
out vec3 eye_tes;
out vec3 light_tes;
out vec2 uv_tes;

uniform sampler2D disptex;
uniform float time;

void main() {
    // 1. First interpolate in MODEL SPACE
    vec3 modelPos = mix(
        mix(position_te[0], position_te[1], gl_TessCoord.x),
        mix(position_te[3], position_te[2], gl_TessCoord.x),
        gl_TessCoord.y
    );

    // 2. Apply model matrix to get world position
    vec4 worldPos = M * vec4(modelPos, 1.0);
    
    // 3. Apply wave displacement in WORLD SPACE (if needed)
    // worldPos.y += sin(time + worldPos.x) * 0.1; // Example wave
    
    // 4. Transform through view and projection
    gl_Position = P * V * worldPos;

    position_tes = worldPos.xyz;

    // Attribute interpolation
    normal_tes = mix(
        mix(normal_te[0], normal_te[1], gl_TessCoord.x),
        mix(normal_te[3], normal_te[2], gl_TessCoord.x),
        gl_TessCoord.y
    );

    eye_tes = mix(
        mix(eye_te[0], eye_te[1], gl_TessCoord.x),
        mix(eye_te[3], eye_te[2], gl_TessCoord.x),
        gl_TessCoord.y
    );

    light_tes = mix(
        mix(light_te[0], light_te[1], gl_TessCoord.x),
        mix(light_te[3], light_te[2], gl_TessCoord.x),
        gl_TessCoord.y
    );

    uv_tes = mix(
        mix(uv_te[0], uv_te[1], gl_TessCoord.x),
        mix(uv_te[3], uv_te[2], gl_TessCoord.x),
        gl_TessCoord.y
    );
}